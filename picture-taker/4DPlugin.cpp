/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Picture Taker
 #	author : miyako
 #	2017/06/19
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Picture Taker

		case 1 :
			DISPLAY_PICTURE_TAKER(pResult, pParams);
			break;

	}
}

// --------------------------------- Picture Taker --------------------------------

#pragma mark JSON

JSONNODE *json_parse_text_param(C_TEXT &t)
{
	std::wstring u32;
	
	uint32_t dataSize = (t.getUTF16Length() * sizeof(wchar_t))+ sizeof(wchar_t);
	std::vector<char> buf(dataSize);
	
	PA_ConvertCharsetToCharset((char *)t.getUTF16StringPtr(),
														 t.getUTF16Length() * sizeof(PA_Unichar),
														 eVTC_UTF_16,
														 (char *)&buf[0],
														 dataSize,
														 eVTC_UTF_32);
	
	u32 = std::wstring((wchar_t *)&buf[0]);

	return json_parse((json_const json_char *)u32.c_str());
}

#pragma mark -

void picture_taker_set_bool(JSONNODE *node, json_const json_char * name, NSString *key)
{
	if(node)
	{
		node = json_get(node, name);
		if(node)
		{
			json_bool_t bool_value = json_as_bool(node);
			IKPictureTaker *pictureTaker = [IKPictureTaker pictureTaker];
			
			[pictureTaker setValue:[NSNumber numberWithBool:bool_value]
											forKey:key];
		}
	}
}

void picture_taker_set_text(JSONNODE *node, json_const json_char * name, NSString *key)
{
	if(node)
	{
		node = json_get(node, name);
		if(node)
		{
			json_char *text_value = json_as_string(node);
			
			std::wstring wstr = std::wstring(text_value);
			C_TEXT t;
			
			uint32_t dataSize = (wstr.length() * sizeof(wchar_t))+ sizeof(PA_Unichar);
			std::vector<char> buf(dataSize);
			
			uint32_t len = PA_ConvertCharsetToCharset((char *)wstr.c_str(),
																								wstr.length() * sizeof(wchar_t),
																								eVTC_UTF_32,
																								(char *)&buf[0],
																								dataSize,
																								eVTC_UTF_16);
			
			t.setUTF16String((const PA_Unichar *)&buf[0], len);

			json_free(text_value);
			
			NSString *s = t.copyUTF16String();
			
			IKPictureTaker *pictureTaker = [IKPictureTaker pictureTaker];
			
			[pictureTaker setValue:[NSString stringWithString:s]
											forKey:key];
			[s release];
		}
	}
}

void picture_taker_set_size(JSONNODE *node, json_const json_char * name1, json_const json_char * name2, NSString *key)
{
	if(node)
	{
		node = json_get(node, name1);
		if(node)
		{
			json_int_t int_value_1 = json_as_int(node);
			node = json_get(node, name2);
			if(node)
			{
				json_int_t int_value_2 = json_as_int(node);
				IKPictureTaker *pictureTaker = [IKPictureTaker pictureTaker];
				[pictureTaker setValue:[NSValue valueWithSize:NSMakeSize(int_value_1,int_value_2)] forKey:key];
			}
		}
	}
}


void _DISPLAY_PICTURE_TAKER(PackagePtr pParams)
{
	IKPictureTaker *pictureTaker = [IKPictureTaker pictureTaker];
	[pictureTaker setMirroring:YES];
	[pictureTaker setInputImage:nil];
	
	PA_Picture Param1 = *(PA_Picture *)(pParams[0]);
	CGImageRef ci = (CGImageRef)PA_CreateNativePictureForScreen(Param1);
	if(ci)
	{
		NSImage *ni = [[NSImage alloc]initWithCGImage:ci size:NSZeroSize];
		[pictureTaker setInputImage:ni];
		CFRelease(ci);
		[ni release];
	}

	C_TEXT Param2;
	Param2.fromParamAtIndex(pParams, 2);
	JSONNODE *json = json_parse_text_param(Param2);
	if(json)
	{
		//default:YES
		picture_taker_set_bool(json, L"allowsVideoCapture", IKPictureTakerAllowsVideoCaptureKey);
		picture_taker_set_bool(json, L"allowsFileChoosing", IKPictureTakerAllowsFileChoosingKey);
		picture_taker_set_bool(json, L"showRecentPicture", IKPictureTakerShowRecentPictureKey);
		picture_taker_set_bool(json, L"updateRecentPicture", IKPictureTakerUpdateRecentPictureKey);
		picture_taker_set_bool(json, L"allowsEditing", IKPictureTakerAllowsEditingKey);

		//default:NO
		picture_taker_set_bool(json, L"showEffects", IKPictureTakerShowEffectsKey);
		picture_taker_set_bool(json, L"showAddressBookPicture", IKPictureTakerShowAddressBookPictureKey);
//		picture_taker_set_bool(json, L"remainOpenAfterValidate", IKPictureTakerRemainOpenAfterValidateKey);

		picture_taker_set_size(json, L"cropAreaWidth", L"cropAreaHeight", IKPictureTakerCropAreaSizeKey);//deprecated
		picture_taker_set_size(json, L"outputImageMaxWidth", L"outputImageMaxHeight", IKPictureTakerOutputImageMaxSizeKey);
		
		json_delete(json);
	}

	C_LONGINT Param3;
	Param3.fromParamAtIndex(pParams, 3);
	
	switch([pictureTaker runModal])
	{
		case NSOKButton:
		{
			NSImage *ni = [pictureTaker outputImage];
			if(ni)
			{
				NSData *imageData = [ni TIFFRepresentation];
				if(imageData)
				{
					PA_Picture *ptpict = ((PA_Picture*)pParams[0]);
					if (*ptpict) PA_DisposePicture(*ptpict);
					*ptpict = PA_CreatePicture((void *)[imageData bytes], (PA_long32)[imageData length]);
				}
			}
			Param3.setIntValue(1);
		}
			break;
		default:
			break;
	}
	Param3.toParamAtIndex(pParams, 3);
}

void DISPLAY_PICTURE_TAKER(sLONG_PTR *pResult, PackagePtr pParams)
{
	PA_RunInMainProcess((PA_RunInMainProcessProcPtr)_DISPLAY_PICTURE_TAKER, pParams);
}

